{"ast":null,"code":"// NFT Storage API key would normally be kept secure in environment variables\n// For this example, we'll use localStorage, but in production you should use environment variables\nconst NFT_STORAGE_API_KEY_KEY = 'nft_storage_api_key';\nconst STORED_METADATA_KEY = 'stored_metadata';\n\n// Save NFT Storage API key\nexport const saveNFTStorageApiKey = apiKey => {\n  localStorage.setItem(NFT_STORAGE_API_KEY_KEY, apiKey);\n};\n\n// Get NFT Storage API key\nexport const getNFTStorageApiKey = () => {\n  return localStorage.getItem(NFT_STORAGE_API_KEY_KEY) || '';\n};\n\n// Upload image to NFT.Storage\nexport const uploadImageToNFTStorage = async file => {\n  const apiKey = getNFTStorageApiKey();\n  if (!apiKey) {\n    throw new Error('NFT Storage API key not found');\n  }\n  const formData = new FormData();\n  formData.append('file', file);\n  const response = await fetch('https://api.nft.storage/upload', {\n    method: 'POST',\n    headers: {\n      Authorization: `Bearer ${apiKey}`\n    },\n    body: formData\n  });\n  if (!response.ok) {\n    throw new Error(`Failed to upload image: ${response.statusText}`);\n  }\n  const data = await response.json();\n  return {\n    cid: data.value.cid,\n    url: `https://ipfs.io/ipfs/${data.value.cid}/${file.name}`,\n    name: file.name,\n    size: file.size\n  };\n};\n\n// Store metadata to NFT.Storage\nexport const storeMetadataToNFTStorage = async metadata => {\n  const apiKey = getNFTStorageApiKey();\n  if (!apiKey) {\n    throw new Error('NFT Storage API key not found');\n  }\n  const response = await fetch('https://api.nft.storage/store', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      Authorization: `Bearer ${apiKey}`\n    },\n    body: JSON.stringify(metadata)\n  });\n  if (!response.ok) {\n    throw new Error(`Failed to store metadata: ${response.statusText}`);\n  }\n  const data = await response.json();\n  const storedMetadata = {\n    id: Date.now().toString(),\n    cid: data.value.cid,\n    url: `https://ipfs.io/ipfs/${data.value.cid}`,\n    metadata,\n    createdAt: new Date().toISOString()\n  };\n\n  // Store in local storage\n  saveStoredMetadata(storedMetadata);\n  return storedMetadata;\n};\n\n// Save stored metadata\nexport const saveStoredMetadata = metadata => {\n  const storedMetadata = getStoredMetadata();\n  storedMetadata.push(metadata);\n  localStorage.setItem(STORED_METADATA_KEY, JSON.stringify(storedMetadata));\n};\n\n// Get all stored metadata\nexport const getStoredMetadata = () => {\n  const storedMetadataStr = localStorage.getItem(STORED_METADATA_KEY);\n  return storedMetadataStr ? JSON.parse(storedMetadataStr) : [];\n};\n\n// Get stored metadata by ID\nexport const getStoredMetadataById = id => {\n  const storedMetadata = getStoredMetadata();\n  return storedMetadata.find(metadata => metadata.id === id);\n};\n\n// Delete stored metadata\nexport const deleteStoredMetadata = id => {\n  const storedMetadata = getStoredMetadata();\n  const filteredMetadata = storedMetadata.filter(metadata => metadata.id !== id);\n  localStorage.setItem(STORED_METADATA_KEY, JSON.stringify(filteredMetadata));\n};","map":{"version":3,"names":["NFT_STORAGE_API_KEY_KEY","STORED_METADATA_KEY","saveNFTStorageApiKey","apiKey","localStorage","setItem","getNFTStorageApiKey","getItem","uploadImageToNFTStorage","file","Error","formData","FormData","append","response","fetch","method","headers","Authorization","body","ok","statusText","data","json","cid","value","url","name","size","storeMetadataToNFTStorage","metadata","JSON","stringify","storedMetadata","id","Date","now","toString","createdAt","toISOString","saveStoredMetadata","getStoredMetadata","push","storedMetadataStr","parse","getStoredMetadataById","find","deleteStoredMetadata","filteredMetadata","filter"],"sources":["/Users/sungwoocho/Desktop/platform/blog/src/services/nft.ts"],"sourcesContent":["import { NFTMetadata, UploadedImage, StoredMetadata } from '../types/nft';\n\n// NFT Storage API key would normally be kept secure in environment variables\n// For this example, we'll use localStorage, but in production you should use environment variables\nconst NFT_STORAGE_API_KEY_KEY = 'nft_storage_api_key';\nconst STORED_METADATA_KEY = 'stored_metadata';\n\n// Save NFT Storage API key\nexport const saveNFTStorageApiKey = (apiKey: string): void => {\n  localStorage.setItem(NFT_STORAGE_API_KEY_KEY, apiKey);\n};\n\n// Get NFT Storage API key\nexport const getNFTStorageApiKey = (): string => {\n  return localStorage.getItem(NFT_STORAGE_API_KEY_KEY) || '';\n};\n\n// Upload image to NFT.Storage\nexport const uploadImageToNFTStorage = async (\n  file: File\n): Promise<UploadedImage> => {\n  const apiKey = getNFTStorageApiKey();\n  if (!apiKey) {\n    throw new Error('NFT Storage API key not found');\n  }\n\n  const formData = new FormData();\n  formData.append('file', file);\n\n  const response = await fetch('https://api.nft.storage/upload', {\n    method: 'POST',\n    headers: {\n      Authorization: `Bearer ${apiKey}`,\n    },\n    body: formData,\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to upload image: ${response.statusText}`);\n  }\n\n  const data = await response.json();\n  return {\n    cid: data.value.cid,\n    url: `https://ipfs.io/ipfs/${data.value.cid}/${file.name}`,\n    name: file.name,\n    size: file.size,\n  };\n};\n\n// Store metadata to NFT.Storage\nexport const storeMetadataToNFTStorage = async (\n  metadata: NFTMetadata\n): Promise<StoredMetadata> => {\n  const apiKey = getNFTStorageApiKey();\n  if (!apiKey) {\n    throw new Error('NFT Storage API key not found');\n  }\n\n  const response = await fetch('https://api.nft.storage/store', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      Authorization: `Bearer ${apiKey}`,\n    },\n    body: JSON.stringify(metadata),\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to store metadata: ${response.statusText}`);\n  }\n\n  const data = await response.json();\n  const storedMetadata: StoredMetadata = {\n    id: Date.now().toString(),\n    cid: data.value.cid,\n    url: `https://ipfs.io/ipfs/${data.value.cid}`,\n    metadata,\n    createdAt: new Date().toISOString(),\n  };\n\n  // Store in local storage\n  saveStoredMetadata(storedMetadata);\n\n  return storedMetadata;\n};\n\n// Save stored metadata\nexport const saveStoredMetadata = (metadata: StoredMetadata): void => {\n  const storedMetadata = getStoredMetadata();\n  storedMetadata.push(metadata);\n  localStorage.setItem(STORED_METADATA_KEY, JSON.stringify(storedMetadata));\n};\n\n// Get all stored metadata\nexport const getStoredMetadata = (): StoredMetadata[] => {\n  const storedMetadataStr = localStorage.getItem(STORED_METADATA_KEY);\n  return storedMetadataStr ? JSON.parse(storedMetadataStr) : [];\n};\n\n// Get stored metadata by ID\nexport const getStoredMetadataById = (id: string): StoredMetadata | undefined => {\n  const storedMetadata = getStoredMetadata();\n  return storedMetadata.find((metadata) => metadata.id === id);\n};\n\n// Delete stored metadata\nexport const deleteStoredMetadata = (id: string): void => {\n  const storedMetadata = getStoredMetadata();\n  const filteredMetadata = storedMetadata.filter((metadata) => metadata.id !== id);\n  localStorage.setItem(STORED_METADATA_KEY, JSON.stringify(filteredMetadata));\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}