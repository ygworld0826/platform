{"ast":null,"code":"// Declare the ethereum property on the window object for TypeScript\n\nconst CONTRACTS_STORAGE_KEY = 'nft_contracts';\n\n// Save NFT Contract Information\nexport const saveNFTContract = contract => {\n  const contracts = getNFTContracts();\n\n  // Check if contract with same address already exists\n  const existingIndex = contracts.findIndex(c => c.address === contract.address);\n  if (existingIndex >= 0) {\n    // Update existing contract\n    contracts[existingIndex] = contract;\n  } else {\n    // Add new contract\n    contracts.push(contract);\n  }\n  localStorage.setItem(CONTRACTS_STORAGE_KEY, JSON.stringify(contracts));\n};\n\n// Get all NFT Contracts\nexport const getNFTContracts = () => {\n  const contractsStr = localStorage.getItem(CONTRACTS_STORAGE_KEY);\n  return contractsStr ? JSON.parse(contractsStr) : [];\n};\n\n// Get NFT Contract by address\nexport const getNFTContractByAddress = address => {\n  const contracts = getNFTContracts();\n  return contracts.find(contract => contract.address.toLowerCase() === address.toLowerCase());\n};\n\n// Delete NFT Contract\nexport const deleteNFTContract = address => {\n  const contracts = getNFTContracts();\n  const filteredContracts = contracts.filter(contract => contract.address.toLowerCase() !== address.toLowerCase());\n  localStorage.setItem(CONTRACTS_STORAGE_KEY, JSON.stringify(filteredContracts));\n};\n\n/**\n * Check if MetaMask is installed\n */\nexport const isMetaMaskInstalled = () => {\n  return typeof window !== 'undefined' && !!window.ethereum;\n};\n\n/**\n * Connect to Web3 Provider (MetaMask)\n */\nexport const connectWallet = async () => {\n  if (!isMetaMaskInstalled()) {\n    throw new Error('MetaMask is not installed. Please install MetaMask to use this feature.');\n  }\n  try {\n    // Request account access\n    const accounts = await window.ethereum.request({\n      method: 'eth_requestAccounts'\n    });\n    return accounts;\n  } catch (error) {\n    console.error('Error connecting to MetaMask:', error);\n    throw error;\n  }\n};\n\n/**\n * Get connected wallet address\n */\nexport const getConnectedAddress = async () => {\n  if (!isMetaMaskInstalled()) {\n    return null;\n  }\n  try {\n    const accounts = await window.ethereum.request({\n      method: 'eth_accounts'\n    });\n    return accounts.length > 0 ? accounts[0] : null;\n  } catch (error) {\n    console.error('Error getting connected address:', error);\n    return null;\n  }\n};\n\n/**\n * Get current network\n */\nexport const getCurrentNetwork = async () => {\n  if (!isMetaMaskInstalled()) {\n    throw new Error('MetaMask is not installed');\n  }\n  try {\n    const chainId = await window.ethereum.request({\n      method: 'eth_chainId'\n    });\n\n    // Convert chainId to network name\n    switch (chainId) {\n      case '0x1':\n        return 'Ethereum Mainnet';\n      case '0x5':\n        return 'Goerli Testnet';\n      case '0xaa36a7':\n        return 'Sepolia Testnet';\n      case '0x89':\n        return 'Polygon Mainnet';\n      case '0x13881':\n        return 'Mumbai Testnet';\n      default:\n        return `Chain ID: ${chainId}`;\n    }\n  } catch (error) {\n    console.error('Error getting current network:', error);\n    throw error;\n  }\n};\n\n/**\n * Mint NFT using contract ABI\n */\nexport const mintNFT = async (contractAddress, abi, tokenURI, toAddress) => {\n  if (!isMetaMaskInstalled()) {\n    return {\n      success: false,\n      error: 'MetaMask is not installed'\n    };\n  }\n  try {\n    // Dynamically import ethers to avoid issues with SSR\n    const {\n      ethers\n    } = await import('ethers');\n\n    // Create Web3Provider\n    const provider = new ethers.providers.Web3Provider(window.ethereum);\n\n    // Get the signer (current user's account)\n    const signer = provider.getSigner();\n\n    // Create a contract instance\n    const contract = new ethers.Contract(contractAddress, abi, signer);\n\n    // Call mint function - adjust this based on your contract's actual function\n    // Most NFT contracts use one of these patterns:\n    let tx;\n\n    // Try different minting patterns based on the contract\n    try {\n      // Pattern 1: mint(to, tokenURI)\n      tx = await contract.mint(toAddress, tokenURI);\n    } catch (error) {\n      try {\n        // Pattern 2: safeMint(to, tokenURI)\n        tx = await contract.safeMint(toAddress, tokenURI);\n      } catch (innerError) {\n        try {\n          // Pattern 3: mintNFT(to, tokenURI)\n          tx = await contract.mintNFT(toAddress, tokenURI);\n        } catch (deepError) {\n          // If all patterns fail, try just calling 'mint' with only the tokenURI\n          // This is common for contracts where msg.sender is the recipient\n          tx = await contract.mint(tokenURI);\n        }\n      }\n    }\n\n    // Wait for the transaction to be mined\n    const receipt = await tx.wait();\n    return {\n      success: true,\n      txHash: receipt.transactionHash\n    };\n  } catch (error) {\n    console.error('Error minting NFT:', error);\n    if (error instanceof Error) {\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n    return {\n      success: false,\n      error: 'Unknown error occurred while minting NFT'\n    };\n  }\n};","map":{"version":3,"names":["CONTRACTS_STORAGE_KEY","saveNFTContract","contract","contracts","getNFTContracts","existingIndex","findIndex","c","address","push","localStorage","setItem","JSON","stringify","contractsStr","getItem","parse","getNFTContractByAddress","find","toLowerCase","deleteNFTContract","filteredContracts","filter","isMetaMaskInstalled","window","ethereum","connectWallet","Error","accounts","request","method","error","console","getConnectedAddress","length","getCurrentNetwork","chainId","mintNFT","contractAddress","abi","tokenURI","toAddress","success","ethers","provider","providers","Web3Provider","signer","getSigner","Contract","tx","mint","safeMint","innerError","deepError","receipt","wait","txHash","transactionHash","message"],"sources":["/Users/sungwoocho/Desktop/platform/blog/src/services/web3.ts"],"sourcesContent":["import { NFTContractInfo } from '../types/nft';\n\n// Declare the ethereum property on the window object for TypeScript\ndeclare global {\n  interface Window {\n    ethereum?: any;\n  }\n}\n\nconst CONTRACTS_STORAGE_KEY = 'nft_contracts';\n\n// Save NFT Contract Information\nexport const saveNFTContract = (contract: NFTContractInfo): void => {\n  const contracts = getNFTContracts();\n  \n  // Check if contract with same address already exists\n  const existingIndex = contracts.findIndex(c => c.address === contract.address);\n  \n  if (existingIndex >= 0) {\n    // Update existing contract\n    contracts[existingIndex] = contract;\n  } else {\n    // Add new contract\n    contracts.push(contract);\n  }\n  \n  localStorage.setItem(CONTRACTS_STORAGE_KEY, JSON.stringify(contracts));\n};\n\n// Get all NFT Contracts\nexport const getNFTContracts = (): NFTContractInfo[] => {\n  const contractsStr = localStorage.getItem(CONTRACTS_STORAGE_KEY);\n  return contractsStr ? JSON.parse(contractsStr) : [];\n};\n\n// Get NFT Contract by address\nexport const getNFTContractByAddress = (address: string): NFTContractInfo | undefined => {\n  const contracts = getNFTContracts();\n  return contracts.find(contract => contract.address.toLowerCase() === address.toLowerCase());\n};\n\n// Delete NFT Contract\nexport const deleteNFTContract = (address: string): void => {\n  const contracts = getNFTContracts();\n  const filteredContracts = contracts.filter(contract => \n    contract.address.toLowerCase() !== address.toLowerCase()\n  );\n  localStorage.setItem(CONTRACTS_STORAGE_KEY, JSON.stringify(filteredContracts));\n};\n\n/**\n * Check if MetaMask is installed\n */\nexport const isMetaMaskInstalled = (): boolean => {\n  return typeof window !== 'undefined' && !!window.ethereum;\n};\n\n/**\n * Connect to Web3 Provider (MetaMask)\n */\nexport const connectWallet = async (): Promise<string[]> => {\n  if (!isMetaMaskInstalled()) {\n    throw new Error('MetaMask is not installed. Please install MetaMask to use this feature.');\n  }\n\n  try {\n    // Request account access\n    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });\n    return accounts as string[];\n  } catch (error) {\n    console.error('Error connecting to MetaMask:', error);\n    throw error;\n  }\n};\n\n/**\n * Get connected wallet address\n */\nexport const getConnectedAddress = async (): Promise<string | null> => {\n  if (!isMetaMaskInstalled()) {\n    return null;\n  }\n\n  try {\n    const accounts = await window.ethereum.request({ method: 'eth_accounts' });\n    return accounts.length > 0 ? accounts[0] : null;\n  } catch (error) {\n    console.error('Error getting connected address:', error);\n    return null;\n  }\n};\n\n/**\n * Get current network\n */\nexport const getCurrentNetwork = async (): Promise<string> => {\n  if (!isMetaMaskInstalled()) {\n    throw new Error('MetaMask is not installed');\n  }\n\n  try {\n    const chainId = await window.ethereum.request({ method: 'eth_chainId' });\n    \n    // Convert chainId to network name\n    switch (chainId) {\n      case '0x1':\n        return 'Ethereum Mainnet';\n      case '0x5':\n        return 'Goerli Testnet';\n      case '0xaa36a7':\n        return 'Sepolia Testnet';\n      case '0x89':\n        return 'Polygon Mainnet';\n      case '0x13881':\n        return 'Mumbai Testnet';\n      default:\n        return `Chain ID: ${chainId}`;\n    }\n  } catch (error) {\n    console.error('Error getting current network:', error);\n    throw error;\n  }\n};\n\n/**\n * Mint NFT using contract ABI\n */\nexport const mintNFT = async (\n  contractAddress: string,\n  abi: any[],\n  tokenURI: string,\n  toAddress: string\n): Promise<{ success: boolean; txHash?: string; error?: string }> => {\n  if (!isMetaMaskInstalled()) {\n    return { success: false, error: 'MetaMask is not installed' };\n  }\n\n  try {\n    // Dynamically import ethers to avoid issues with SSR\n    const { ethers } = await import('ethers');\n    \n    // Create Web3Provider\n    const provider = new ethers.providers.Web3Provider(window.ethereum);\n    \n    // Get the signer (current user's account)\n    const signer = provider.getSigner();\n    \n    // Create a contract instance\n    const contract = new ethers.Contract(contractAddress, abi, signer);\n    \n    // Call mint function - adjust this based on your contract's actual function\n    // Most NFT contracts use one of these patterns:\n    let tx;\n    \n    // Try different minting patterns based on the contract\n    try {\n      // Pattern 1: mint(to, tokenURI)\n      tx = await contract.mint(toAddress, tokenURI);\n    } catch (error) {\n      try {\n        // Pattern 2: safeMint(to, tokenURI)\n        tx = await contract.safeMint(toAddress, tokenURI);\n      } catch (innerError) {\n        try {\n          // Pattern 3: mintNFT(to, tokenURI)\n          tx = await contract.mintNFT(toAddress, tokenURI);\n        } catch (deepError) {\n          // If all patterns fail, try just calling 'mint' with only the tokenURI\n          // This is common for contracts where msg.sender is the recipient\n          tx = await contract.mint(tokenURI);\n        }\n      }\n    }\n    \n    // Wait for the transaction to be mined\n    const receipt = await tx.wait();\n    \n    return {\n      success: true,\n      txHash: receipt.transactionHash\n    };\n  } catch (error) {\n    console.error('Error minting NFT:', error);\n    \n    if (error instanceof Error) {\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n    \n    return {\n      success: false,\n      error: 'Unknown error occurred while minting NFT'\n    };\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}