{"ast":null,"code":"// Declare the ethereum property on the window object for TypeScript\n\nconst CONTRACTS_STORAGE_KEY = 'nft_contracts';\n\n// Save NFT Contract Information\nexport const saveNFTContract = contract => {\n  const contracts = getNFTContracts();\n\n  // Check if contract with same address already exists\n  const existingIndex = contracts.findIndex(c => c.address === contract.address);\n  if (existingIndex >= 0) {\n    // Update existing contract\n    contracts[existingIndex] = contract;\n  } else {\n    // Add new contract\n    contracts.push(contract);\n  }\n  localStorage.setItem(CONTRACTS_STORAGE_KEY, JSON.stringify(contracts));\n};\n\n// Get all NFT Contracts\nexport const getNFTContracts = () => {\n  const contractsStr = localStorage.getItem(CONTRACTS_STORAGE_KEY);\n  return contractsStr ? JSON.parse(contractsStr) : [];\n};\n\n// Get NFT Contract by address\nexport const getNFTContractByAddress = address => {\n  const contracts = getNFTContracts();\n  return contracts.find(contract => contract.address.toLowerCase() === address.toLowerCase());\n};\n\n// Delete NFT Contract\nexport const deleteNFTContract = address => {\n  const contracts = getNFTContracts();\n  const filteredContracts = contracts.filter(contract => contract.address.toLowerCase() !== address.toLowerCase());\n  localStorage.setItem(CONTRACTS_STORAGE_KEY, JSON.stringify(filteredContracts));\n};\n\n/**\n * Check if MetaMask is installed\n */\nexport const isMetaMaskInstalled = () => {\n  return typeof window !== 'undefined' && !!window.ethereum;\n};\n\n/**\n * Connect to Web3 Provider (MetaMask)\n */\nexport const connectWallet = async () => {\n  if (!isMetaMaskInstalled()) {\n    throw new Error('MetaMask is not installed. Please install MetaMask to use this feature.');\n  }\n  try {\n    // Request account access\n    const accounts = await window.ethereum.request({\n      method: 'eth_requestAccounts'\n    });\n    return accounts;\n  } catch (error) {\n    console.error('Error connecting to MetaMask:', error);\n    throw error;\n  }\n};\n\n/**\n * Get connected wallet address\n */\nexport const getConnectedAddress = async () => {\n  if (!isMetaMaskInstalled()) {\n    return null;\n  }\n  try {\n    const accounts = await window.ethereum.request({\n      method: 'eth_accounts'\n    });\n    return accounts.length > 0 ? accounts[0] : null;\n  } catch (error) {\n    console.error('Error getting connected address:', error);\n    return null;\n  }\n};\n\n/**\n * Get current network\n */\nexport const getCurrentNetwork = async () => {\n  if (!isMetaMaskInstalled()) {\n    throw new Error('MetaMask is not installed');\n  }\n  try {\n    const chainId = await window.ethereum.request({\n      method: 'eth_chainId'\n    });\n\n    // Convert chainId to network name\n    switch (chainId) {\n      case '0x1':\n        return 'Ethereum Mainnet';\n      case '0x5':\n        return 'Goerli Testnet';\n      case '0xaa36a7':\n        return 'Sepolia Testnet';\n      case '0x89':\n        return 'Polygon Mainnet';\n      case '0x13881':\n        return 'Mumbai Testnet';\n      default:\n        return `Chain ID: ${chainId}`;\n    }\n  } catch (error) {\n    console.error('Error getting current network:', error);\n    throw error;\n  }\n};\n\n/**\n * Get ethers.js library\n * This is a dynamic import to avoid issues with SSR\n */\nconst getEthers = async () => {\n  const ethersModule = await import('ethers');\n  return ethersModule.ethers;\n};\n\n/**\n * Mint NFT using contract ABI\n */\nexport const mintNFT = async (contractAddress, abi, tokenURI, toAddress) => {\n  if (!isMetaMaskInstalled()) {\n    return {\n      success: false,\n      error: 'MetaMask is not installed'\n    };\n  }\n  try {\n    // Load ethers.js dynamically\n    const ethers = await getEthers();\n\n    // Create a Web3Provider using the Ethereum provider from the browser\n    const provider = new ethers.providers.Web3Provider(window.ethereum);\n\n    // Get the signer (current user's account)\n    const signer = provider.getSigner();\n\n    // Create a contract instance\n    const contract = new ethers.Contract(contractAddress, abi, signer);\n\n    // Try to determine the correct minting function\n    const contractFunctions = Object.keys(contract.functions);\n    let mintFunction = null;\n    let mintArgs = [];\n\n    // Try to find the appropriate mint function\n    if (contractFunctions.includes('mint(address,string)')) {\n      mintFunction = contract.functions['mint(address,string)'];\n      mintArgs = [toAddress, tokenURI];\n    } else if (contractFunctions.includes('safeMint(address,string)')) {\n      mintFunction = contract.functions['safeMint(address,string)'];\n      mintArgs = [toAddress, tokenURI];\n    } else if (contractFunctions.includes('mintNFT(address,string)')) {\n      mintFunction = contract.functions['mintNFT(address,string)'];\n      mintArgs = [toAddress, tokenURI];\n    } else if (contractFunctions.includes('mint(string)')) {\n      mintFunction = contract.functions['mint(string)'];\n      mintArgs = [tokenURI];\n    } else {\n      // Generic fallback - try the most common pattern\n      mintFunction = contract.mint;\n\n      // Try to determine if it accepts 1 or 2 arguments\n      try {\n        const mintFunctionAbi = abi.find(item => item.type === 'function' && item.name === 'mint');\n        if (mintFunctionAbi && mintFunctionAbi.inputs) {\n          if (mintFunctionAbi.inputs.length === 1) {\n            mintArgs = [tokenURI];\n          } else {\n            mintArgs = [toAddress, tokenURI];\n          }\n        } else {\n          // Default to 2 arguments\n          mintArgs = [toAddress, tokenURI];\n        }\n      } catch (error) {\n        // Default to 2 arguments if error\n        mintArgs = [toAddress, tokenURI];\n      }\n    }\n    if (!mintFunction) {\n      return {\n        success: false,\n        error: 'Could not identify minting function in contract'\n      };\n    }\n\n    // Call the mint function with the appropriate arguments\n    const tx = await mintFunction(...mintArgs);\n\n    // Wait for the transaction to be mined\n    const receipt = await tx.wait();\n    return {\n      success: true,\n      txHash: receipt.transactionHash\n    };\n  } catch (error) {\n    console.error('Error minting NFT:', error);\n    if (error instanceof Error) {\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n    return {\n      success: false,\n      error: 'Unknown error occurred while minting NFT'\n    };\n  }\n};","map":{"version":3,"names":["CONTRACTS_STORAGE_KEY","saveNFTContract","contract","contracts","getNFTContracts","existingIndex","findIndex","c","address","push","localStorage","setItem","JSON","stringify","contractsStr","getItem","parse","getNFTContractByAddress","find","toLowerCase","deleteNFTContract","filteredContracts","filter","isMetaMaskInstalled","window","ethereum","connectWallet","Error","accounts","request","method","error","console","getConnectedAddress","length","getCurrentNetwork","chainId","getEthers","ethersModule","ethers","mintNFT","contractAddress","abi","tokenURI","toAddress","success","provider","providers","Web3Provider","signer","getSigner","Contract","contractFunctions","Object","keys","functions","mintFunction","mintArgs","includes","mint","mintFunctionAbi","item","type","name","inputs","tx","receipt","wait","txHash","transactionHash","message"],"sources":["/Users/sungwoocho/Desktop/platform/src/services/web3.ts"],"sourcesContent":["import { NFTContractInfo } from '../types/nft';\n\n// Declare the ethereum property on the window object for TypeScript\ndeclare global {\n  interface Window {\n    ethereum?: {\n      request: (args: { method: string; params?: any[] }) => Promise<any>;\n      on: (event: string, callback: (...args: any[]) => void) => void;\n      removeListener: (event: string, callback: (...args: any[]) => void) => void;\n    };\n  }\n}\n\nconst CONTRACTS_STORAGE_KEY = 'nft_contracts';\n\n// Save NFT Contract Information\nexport const saveNFTContract = (contract: NFTContractInfo): void => {\n  const contracts = getNFTContracts();\n  \n  // Check if contract with same address already exists\n  const existingIndex = contracts.findIndex(c => c.address === contract.address);\n  \n  if (existingIndex >= 0) {\n    // Update existing contract\n    contracts[existingIndex] = contract;\n  } else {\n    // Add new contract\n    contracts.push(contract);\n  }\n  \n  localStorage.setItem(CONTRACTS_STORAGE_KEY, JSON.stringify(contracts));\n};\n\n// Get all NFT Contracts\nexport const getNFTContracts = (): NFTContractInfo[] => {\n  const contractsStr = localStorage.getItem(CONTRACTS_STORAGE_KEY);\n  return contractsStr ? JSON.parse(contractsStr) : [];\n};\n\n// Get NFT Contract by address\nexport const getNFTContractByAddress = (address: string): NFTContractInfo | undefined => {\n  const contracts = getNFTContracts();\n  return contracts.find(contract => contract.address.toLowerCase() === address.toLowerCase());\n};\n\n// Delete NFT Contract\nexport const deleteNFTContract = (address: string): void => {\n  const contracts = getNFTContracts();\n  const filteredContracts = contracts.filter(contract => \n    contract.address.toLowerCase() !== address.toLowerCase()\n  );\n  localStorage.setItem(CONTRACTS_STORAGE_KEY, JSON.stringify(filteredContracts));\n};\n\n/**\n * Check if MetaMask is installed\n */\nexport const isMetaMaskInstalled = (): boolean => {\n  return typeof window !== 'undefined' && !!window.ethereum;\n};\n\n/**\n * Connect to Web3 Provider (MetaMask)\n */\nexport const connectWallet = async (): Promise<string[]> => {\n  if (!isMetaMaskInstalled()) {\n    throw new Error('MetaMask is not installed. Please install MetaMask to use this feature.');\n  }\n\n  try {\n    // Request account access\n    const accounts = await window.ethereum!.request({ method: 'eth_requestAccounts' });\n    return accounts as string[];\n  } catch (error) {\n    console.error('Error connecting to MetaMask:', error);\n    throw error;\n  }\n};\n\n/**\n * Get connected wallet address\n */\nexport const getConnectedAddress = async (): Promise<string | null> => {\n  if (!isMetaMaskInstalled()) {\n    return null;\n  }\n\n  try {\n    const accounts = await window.ethereum!.request({ method: 'eth_accounts' });\n    return accounts.length > 0 ? accounts[0] : null;\n  } catch (error) {\n    console.error('Error getting connected address:', error);\n    return null;\n  }\n};\n\n/**\n * Get current network\n */\nexport const getCurrentNetwork = async (): Promise<string> => {\n  if (!isMetaMaskInstalled()) {\n    throw new Error('MetaMask is not installed');\n  }\n\n  try {\n    const chainId = await window.ethereum!.request({ method: 'eth_chainId' });\n    \n    // Convert chainId to network name\n    switch (chainId) {\n      case '0x1':\n        return 'Ethereum Mainnet';\n      case '0x5':\n        return 'Goerli Testnet';\n      case '0xaa36a7':\n        return 'Sepolia Testnet';\n      case '0x89':\n        return 'Polygon Mainnet';\n      case '0x13881':\n        return 'Mumbai Testnet';\n      default:\n        return `Chain ID: ${chainId}`;\n    }\n  } catch (error) {\n    console.error('Error getting current network:', error);\n    throw error;\n  }\n};\n\n/**\n * Get ethers.js library\n * This is a dynamic import to avoid issues with SSR\n */\nconst getEthers = async () => {\n  const ethersModule = await import('ethers');\n  return ethersModule.ethers;\n};\n\n/**\n * Mint NFT using contract ABI\n */\nexport const mintNFT = async (\n  contractAddress: string,\n  abi: any[],\n  tokenURI: string,\n  toAddress: string\n): Promise<{ success: boolean; txHash?: string; error?: string }> => {\n  if (!isMetaMaskInstalled()) {\n    return { success: false, error: 'MetaMask is not installed' };\n  }\n\n  try {\n    // Load ethers.js dynamically\n    const ethers = await getEthers();\n    \n    // Create a Web3Provider using the Ethereum provider from the browser\n    const provider = new ethers.providers.Web3Provider(window.ethereum);\n    \n    // Get the signer (current user's account)\n    const signer = provider.getSigner();\n    \n    // Create a contract instance\n    const contract = new ethers.Contract(contractAddress, abi, signer);\n    \n    // Try to determine the correct minting function\n    const contractFunctions = Object.keys(contract.functions);\n    \n    let mintFunction = null;\n    let mintArgs = [];\n    \n    // Try to find the appropriate mint function\n    if (contractFunctions.includes('mint(address,string)')) {\n      mintFunction = contract.functions['mint(address,string)'];\n      mintArgs = [toAddress, tokenURI];\n    } else if (contractFunctions.includes('safeMint(address,string)')) {\n      mintFunction = contract.functions['safeMint(address,string)'];\n      mintArgs = [toAddress, tokenURI];\n    } else if (contractFunctions.includes('mintNFT(address,string)')) {\n      mintFunction = contract.functions['mintNFT(address,string)'];\n      mintArgs = [toAddress, tokenURI];\n    } else if (contractFunctions.includes('mint(string)')) {\n      mintFunction = contract.functions['mint(string)'];\n      mintArgs = [tokenURI];\n    } else {\n      // Generic fallback - try the most common pattern\n      mintFunction = contract.mint;\n      \n      // Try to determine if it accepts 1 or 2 arguments\n      try {\n        const mintFunctionAbi = abi.find(item => \n          item.type === 'function' && \n          item.name === 'mint'\n        );\n        \n        if (mintFunctionAbi && mintFunctionAbi.inputs) {\n          if (mintFunctionAbi.inputs.length === 1) {\n            mintArgs = [tokenURI];\n          } else {\n            mintArgs = [toAddress, tokenURI];\n          }\n        } else {\n          // Default to 2 arguments\n          mintArgs = [toAddress, tokenURI];\n        }\n      } catch (error) {\n        // Default to 2 arguments if error\n        mintArgs = [toAddress, tokenURI];\n      }\n    }\n    \n    if (!mintFunction) {\n      return { \n        success: false, \n        error: 'Could not identify minting function in contract' \n      };\n    }\n    \n    // Call the mint function with the appropriate arguments\n    const tx = await mintFunction(...mintArgs);\n    \n    // Wait for the transaction to be mined\n    const receipt = await tx.wait();\n    \n    return {\n      success: true,\n      txHash: receipt.transactionHash\n    };\n  } catch (error) {\n    console.error('Error minting NFT:', error);\n    \n    if (error instanceof Error) {\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n    \n    return {\n      success: false,\n      error: 'Unknown error occurred while minting NFT'\n    };\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}