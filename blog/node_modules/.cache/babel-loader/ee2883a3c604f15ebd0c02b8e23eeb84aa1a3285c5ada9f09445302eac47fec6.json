{"ast":null,"code":"const CONTRACTS_STORAGE_KEY = 'nft_contracts';\n\n// Save NFT Contract Information\nexport const saveNFTContract = contract => {\n  const contracts = getNFTContracts();\n\n  // Check if contract with same address already exists\n  const existingIndex = contracts.findIndex(c => c.address === contract.address);\n  if (existingIndex >= 0) {\n    // Update existing contract\n    contracts[existingIndex] = contract;\n  } else {\n    // Add new contract\n    contracts.push(contract);\n  }\n  localStorage.setItem(CONTRACTS_STORAGE_KEY, JSON.stringify(contracts));\n};\n\n// Get all NFT Contracts\nexport const getNFTContracts = () => {\n  const contractsStr = localStorage.getItem(CONTRACTS_STORAGE_KEY);\n  return contractsStr ? JSON.parse(contractsStr) : [];\n};\n\n// Get NFT Contract by address\nexport const getNFTContractByAddress = address => {\n  const contracts = getNFTContracts();\n  return contracts.find(contract => contract.address.toLowerCase() === address.toLowerCase());\n};\n\n// Delete NFT Contract\nexport const deleteNFTContract = address => {\n  const contracts = getNFTContracts();\n  const filteredContracts = contracts.filter(contract => contract.address.toLowerCase() !== address.toLowerCase());\n  localStorage.setItem(CONTRACTS_STORAGE_KEY, JSON.stringify(filteredContracts));\n};\n\n// Connect to Web3 Provider (MetaMask)\nexport const connectWallet = async () => {\n  // Check if MetaMask is installed\n  if (!window.ethereum) {\n    throw new Error('MetaMask is not installed. Please install MetaMask to use this feature.');\n  }\n  try {\n    // Request account access\n    const accounts = await window.ethereum.request({\n      method: 'eth_requestAccounts'\n    });\n    return accounts;\n  } catch (error) {\n    console.error('Error connecting to MetaMask:', error);\n    throw error;\n  }\n};\n\n// Get connected wallet address\nexport const getConnectedAddress = async () => {\n  if (!window.ethereum) {\n    return null;\n  }\n  try {\n    const accounts = await window.ethereum.request({\n      method: 'eth_accounts'\n    });\n    return accounts.length > 0 ? accounts[0] : null;\n  } catch (error) {\n    console.error('Error getting connected address:', error);\n    return null;\n  }\n};\n\n// Get current network\nexport const getCurrentNetwork = async () => {\n  if (!window.ethereum) {\n    throw new Error('MetaMask is not installed');\n  }\n  try {\n    const chainId = await window.ethereum.request({\n      method: 'eth_chainId'\n    });\n\n    // Convert chainId to network name\n    switch (chainId) {\n      case '0x1':\n        return 'Ethereum Mainnet';\n      case '0x5':\n        return 'Goerli Testnet';\n      case '0xaa36a7':\n        return 'Sepolia Testnet';\n      case '0x89':\n        return 'Polygon Mainnet';\n      case '0x13881':\n        return 'Mumbai Testnet';\n      default:\n        return `Chain ID: ${chainId}`;\n    }\n  } catch (error) {\n    console.error('Error getting current network:', error);\n    throw error;\n  }\n};\n\n// Mint NFT using contract ABI\nexport const mintNFT = async (contractAddress, abi, tokenURI, toAddress) => {\n  if (!window.ethereum) {\n    return {\n      success: false,\n      error: 'MetaMask is not installed'\n    };\n  }\n  try {\n    const ethereum = window.ethereum;\n\n    // Create Web3 instance\n    const Web3 = require('web3');\n    const web3 = new Web3(ethereum);\n\n    // Create contract instance\n    const contract = new web3.eth.Contract(abi, contractAddress);\n\n    // Get connected account\n    const accounts = await ethereum.request({\n      method: 'eth_accounts'\n    });\n    if (accounts.length === 0) {\n      return {\n        success: false,\n        error: 'No connected account found'\n      };\n    }\n\n    // Call mint function\n    // Note: Different contracts might have different function signatures for minting\n    // This is a common pattern, but might need to be adjusted based on your specific contract\n    const tx = await contract.methods.mint(toAddress, tokenURI).send({\n      from: accounts[0]\n    });\n    return {\n      success: true,\n      txHash: tx.transactionHash\n    };\n  } catch (error) {\n    console.error('Error minting NFT:', error);\n    return {\n      success: false,\n      error: error.message || 'Unknown error occurred while minting NFT'\n    };\n  }\n};","map":{"version":3,"names":["CONTRACTS_STORAGE_KEY","saveNFTContract","contract","contracts","getNFTContracts","existingIndex","findIndex","c","address","push","localStorage","setItem","JSON","stringify","contractsStr","getItem","parse","getNFTContractByAddress","find","toLowerCase","deleteNFTContract","filteredContracts","filter","connectWallet","window","ethereum","Error","accounts","request","method","error","console","getConnectedAddress","length","getCurrentNetwork","chainId","mintNFT","contractAddress","abi","tokenURI","toAddress","success","Web3","require","web3","eth","Contract","tx","methods","mint","send","from","txHash","transactionHash","message"],"sources":["/Users/sungwoocho/Desktop/platform/src/services/web3.ts"],"sourcesContent":["import { NFTContractInfo } from '../types/nft';\n\nconst CONTRACTS_STORAGE_KEY = 'nft_contracts';\n\n// Save NFT Contract Information\nexport const saveNFTContract = (contract: NFTContractInfo): void => {\n  const contracts = getNFTContracts();\n  \n  // Check if contract with same address already exists\n  const existingIndex = contracts.findIndex(c => c.address === contract.address);\n  \n  if (existingIndex >= 0) {\n    // Update existing contract\n    contracts[existingIndex] = contract;\n  } else {\n    // Add new contract\n    contracts.push(contract);\n  }\n  \n  localStorage.setItem(CONTRACTS_STORAGE_KEY, JSON.stringify(contracts));\n};\n\n// Get all NFT Contracts\nexport const getNFTContracts = (): NFTContractInfo[] => {\n  const contractsStr = localStorage.getItem(CONTRACTS_STORAGE_KEY);\n  return contractsStr ? JSON.parse(contractsStr) : [];\n};\n\n// Get NFT Contract by address\nexport const getNFTContractByAddress = (address: string): NFTContractInfo | undefined => {\n  const contracts = getNFTContracts();\n  return contracts.find(contract => contract.address.toLowerCase() === address.toLowerCase());\n};\n\n// Delete NFT Contract\nexport const deleteNFTContract = (address: string): void => {\n  const contracts = getNFTContracts();\n  const filteredContracts = contracts.filter(contract => contract.address.toLowerCase() !== address.toLowerCase());\n  localStorage.setItem(CONTRACTS_STORAGE_KEY, JSON.stringify(filteredContracts));\n};\n\n// Connect to Web3 Provider (MetaMask)\nexport const connectWallet = async (): Promise<string[]> => {\n  // Check if MetaMask is installed\n  if (!(window as any).ethereum) {\n    throw new Error('MetaMask is not installed. Please install MetaMask to use this feature.');\n  }\n\n  try {\n    // Request account access\n    const accounts = await (window as any).ethereum.request({ method: 'eth_requestAccounts' });\n    return accounts;\n  } catch (error) {\n    console.error('Error connecting to MetaMask:', error);\n    throw error;\n  }\n};\n\n// Get connected wallet address\nexport const getConnectedAddress = async (): Promise<string | null> => {\n  if (!(window as any).ethereum) {\n    return null;\n  }\n\n  try {\n    const accounts = await (window as any).ethereum.request({ method: 'eth_accounts' });\n    return accounts.length > 0 ? accounts[0] : null;\n  } catch (error) {\n    console.error('Error getting connected address:', error);\n    return null;\n  }\n};\n\n// Get current network\nexport const getCurrentNetwork = async (): Promise<string> => {\n  if (!(window as any).ethereum) {\n    throw new Error('MetaMask is not installed');\n  }\n\n  try {\n    const chainId = await (window as any).ethereum.request({ method: 'eth_chainId' });\n    \n    // Convert chainId to network name\n    switch (chainId) {\n      case '0x1':\n        return 'Ethereum Mainnet';\n      case '0x5':\n        return 'Goerli Testnet';\n      case '0xaa36a7':\n        return 'Sepolia Testnet';\n      case '0x89':\n        return 'Polygon Mainnet';\n      case '0x13881':\n        return 'Mumbai Testnet';\n      default:\n        return `Chain ID: ${chainId}`;\n    }\n  } catch (error) {\n    console.error('Error getting current network:', error);\n    throw error;\n  }\n};\n\n// Mint NFT using contract ABI\nexport const mintNFT = async (\n  contractAddress: string,\n  abi: any[],\n  tokenURI: string,\n  toAddress: string\n): Promise<{ success: boolean; txHash?: string; error?: string }> => {\n  if (!(window as any).ethereum) {\n    return { success: false, error: 'MetaMask is not installed' };\n  }\n\n  try {\n    const ethereum = (window as any).ethereum;\n    \n    // Create Web3 instance\n    const Web3 = require('web3');\n    const web3 = new Web3(ethereum);\n    \n    // Create contract instance\n    const contract = new web3.eth.Contract(abi, contractAddress);\n    \n    // Get connected account\n    const accounts = await ethereum.request({ method: 'eth_accounts' });\n    if (accounts.length === 0) {\n      return { success: false, error: 'No connected account found' };\n    }\n    \n    // Call mint function\n    // Note: Different contracts might have different function signatures for minting\n    // This is a common pattern, but might need to be adjusted based on your specific contract\n    const tx = await contract.methods.mint(toAddress, tokenURI).send({\n      from: accounts[0],\n    });\n    \n    return {\n      success: true,\n      txHash: tx.transactionHash\n    };\n  } catch (error) {\n    console.error('Error minting NFT:', error);\n    return {\n      success: false,\n      error: error.message || 'Unknown error occurred while minting NFT'\n    };\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}