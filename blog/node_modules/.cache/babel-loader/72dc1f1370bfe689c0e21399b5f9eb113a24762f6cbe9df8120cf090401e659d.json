{"ast":null,"code":"// Declare the ethereum property on the window object for TypeScript\nconst CONTRACTS_STORAGE_KEY='nft_contracts';// Save NFT Contract Information\nexport const saveNFTContract=contract=>{const contracts=getNFTContracts();// Check if contract with same address already exists\nconst existingIndex=contracts.findIndex(c=>c.address===contract.address);if(existingIndex>=0){// Update existing contract\ncontracts[existingIndex]=contract;}else{// Add new contract\ncontracts.push(contract);}localStorage.setItem(CONTRACTS_STORAGE_KEY,JSON.stringify(contracts));};// Get all NFT Contracts\nexport const getNFTContracts=()=>{const contractsStr=localStorage.getItem(CONTRACTS_STORAGE_KEY);return contractsStr?JSON.parse(contractsStr):[];};// Get NFT Contract by address\nexport const getNFTContractByAddress=address=>{const contracts=getNFTContracts();return contracts.find(contract=>contract.address.toLowerCase()===address.toLowerCase());};// Delete NFT Contract\nexport const deleteNFTContract=address=>{const contracts=getNFTContracts();const filteredContracts=contracts.filter(contract=>contract.address.toLowerCase()!==address.toLowerCase());localStorage.setItem(CONTRACTS_STORAGE_KEY,JSON.stringify(filteredContracts));};/**\n * Check if MetaMask is installed\n */export const isMetaMaskInstalled=()=>{return typeof window!=='undefined'&&!!window.ethereum;};/**\n * Connect to Web3 Provider (MetaMask)\n */export const connectWallet=async()=>{if(!isMetaMaskInstalled()){throw new Error('MetaMask is not installed. Please install MetaMask to use this feature.');}try{// Request account access\nconst accounts=await window.ethereum.request({method:'eth_requestAccounts'});return accounts;}catch(error){console.error('Error connecting to MetaMask:',error);throw error;}};/**\n * Get connected wallet address\n */export const getConnectedAddress=async()=>{if(!isMetaMaskInstalled()){return null;}try{const accounts=await window.ethereum.request({method:'eth_accounts'});return accounts.length>0?accounts[0]:null;}catch(error){console.error('Error getting connected address:',error);return null;}};/**\n * Get current network\n */export const getCurrentNetwork=async()=>{if(!isMetaMaskInstalled()){throw new Error('MetaMask is not installed');}try{const chainId=await window.ethereum.request({method:'eth_chainId'});// Convert chainId to network name\nswitch(chainId){case'0x1':return'Ethereum Mainnet';case'0x5':return'Goerli Testnet';case'0xaa36a7':return'Sepolia Testnet';case'0x89':return'Polygon Mainnet';case'0x13881':return'Kairos Testnet';default:return`Chain ID: ${chainId}`;}}catch(error){console.error('Error getting current network:',error);throw error;}};/**\n * Mint NFT using contract ABI\n */export const mintNFT=async(contractAddress,abi,tokenURI,toAddress)=>{if(!isMetaMaskInstalled()){return{success:false,error:'MetaMask is not installed'};}try{// Dynamically import ethers to avoid issues with SSR\nconst{ethers}=await import('ethers');// Create Web3Provider\nconst provider=new ethers.providers.Web3Provider(window.ethereum);// Get the signer (current user's account)\nconst signer=provider.getSigner();// Create a contract instance\nconst contract=new ethers.Contract(contractAddress,abi,signer);// Call mint function - adjust this based on your contract's actual function\n// Most NFT contracts use one of these patterns:\nlet tx;// Try different minting patterns based on the contract\ntry{// Pattern 1: mint(to, tokenURI)\ntx=await contract.mint(toAddress,tokenURI);}catch(error){try{// Pattern 2: safeMint(to, tokenURI)\ntx=await contract.safeMint(toAddress,tokenURI);}catch(innerError){try{// Pattern 3: mintNFT(to, tokenURI)\ntx=await contract.mintNFT(toAddress,tokenURI);}catch(deepError){// If all patterns fail, try just calling 'mint' with only the tokenURI\n// This is common for contracts where msg.sender is the recipient\ntx=await contract.mint(tokenURI);}}}// Wait for the transaction to be mined\nconst receipt=await tx.wait();return{success:true,txHash:receipt.transactionHash};}catch(error){console.error('Error minting NFT:',error);if(error instanceof Error){return{success:false,error:error.message};}return{success:false,error:'Unknown error occurred while minting NFT'};}};","map":{"version":3,"names":["CONTRACTS_STORAGE_KEY","saveNFTContract","contract","contracts","getNFTContracts","existingIndex","findIndex","c","address","push","localStorage","setItem","JSON","stringify","contractsStr","getItem","parse","getNFTContractByAddress","find","toLowerCase","deleteNFTContract","filteredContracts","filter","isMetaMaskInstalled","window","ethereum","connectWallet","Error","accounts","request","method","error","console","getConnectedAddress","length","getCurrentNetwork","chainId","mintNFT","contractAddress","abi","tokenURI","toAddress","success","ethers","provider","providers","Web3Provider","signer","getSigner","Contract","tx","mint","safeMint","innerError","deepError","receipt","wait","txHash","transactionHash","message"],"sources":["/Users/sungwoocho/Desktop/platform/blog/src/services/web3.ts"],"sourcesContent":["import { NFTContractInfo } from '../types/nft';\n\n// Declare the ethereum property on the window object for TypeScript\ndeclare global {\n  interface Window {\n    ethereum?: any;\n  }\n}\n\nconst CONTRACTS_STORAGE_KEY = 'nft_contracts';\n\n// Save NFT Contract Information\nexport const saveNFTContract = (contract: NFTContractInfo): void => {\n  const contracts = getNFTContracts();\n  \n  // Check if contract with same address already exists\n  const existingIndex = contracts.findIndex(c => c.address === contract.address);\n  \n  if (existingIndex >= 0) {\n    // Update existing contract\n    contracts[existingIndex] = contract;\n  } else {\n    // Add new contract\n    contracts.push(contract);\n  }\n  \n  localStorage.setItem(CONTRACTS_STORAGE_KEY, JSON.stringify(contracts));\n};\n\n// Get all NFT Contracts\nexport const getNFTContracts = (): NFTContractInfo[] => {\n  const contractsStr = localStorage.getItem(CONTRACTS_STORAGE_KEY);\n  return contractsStr ? JSON.parse(contractsStr) : [];\n};\n\n// Get NFT Contract by address\nexport const getNFTContractByAddress = (address: string): NFTContractInfo | undefined => {\n  const contracts = getNFTContracts();\n  return contracts.find(contract => contract.address.toLowerCase() === address.toLowerCase());\n};\n\n// Delete NFT Contract\nexport const deleteNFTContract = (address: string): void => {\n  const contracts = getNFTContracts();\n  const filteredContracts = contracts.filter(contract => \n    contract.address.toLowerCase() !== address.toLowerCase()\n  );\n  localStorage.setItem(CONTRACTS_STORAGE_KEY, JSON.stringify(filteredContracts));\n};\n\n/**\n * Check if MetaMask is installed\n */\nexport const isMetaMaskInstalled = (): boolean => {\n  return typeof window !== 'undefined' && !!window.ethereum;\n};\n\n/**\n * Connect to Web3 Provider (MetaMask)\n */\nexport const connectWallet = async (): Promise<string[]> => {\n  if (!isMetaMaskInstalled()) {\n    throw new Error('MetaMask is not installed. Please install MetaMask to use this feature.');\n  }\n\n  try {\n    // Request account access\n    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });\n    return accounts as string[];\n  } catch (error) {\n    console.error('Error connecting to MetaMask:', error);\n    throw error;\n  }\n};\n\n/**\n * Get connected wallet address\n */\nexport const getConnectedAddress = async (): Promise<string | null> => {\n  if (!isMetaMaskInstalled()) {\n    return null;\n  }\n\n  try {\n    const accounts = await window.ethereum.request({ method: 'eth_accounts' });\n    return accounts.length > 0 ? accounts[0] : null;\n  } catch (error) {\n    console.error('Error getting connected address:', error);\n    return null;\n  }\n};\n\n/**\n * Get current network\n */\nexport const getCurrentNetwork = async (): Promise<string> => {\n  if (!isMetaMaskInstalled()) {\n    throw new Error('MetaMask is not installed');\n  }\n\n  try {\n    const chainId = await window.ethereum.request({ method: 'eth_chainId' });\n    \n    // Convert chainId to network name\n    switch (chainId) {\n      case '0x1':\n        return 'Ethereum Mainnet';\n      case '0x5':\n        return 'Goerli Testnet';\n      case '0xaa36a7':\n        return 'Sepolia Testnet';\n      case '0x89':\n        return 'Polygon Mainnet';\n      case '0x13881':\n        return 'Kairos Testnet';\n      default:\n        return `Chain ID: ${chainId}`;\n    }\n  } catch (error) {\n    console.error('Error getting current network:', error);\n    throw error;\n  }\n};\n\n/**\n * Mint NFT using contract ABI\n */\nexport const mintNFT = async (\n  contractAddress: string,\n  abi: any[],\n  tokenURI: string,\n  toAddress: string\n): Promise<{ success: boolean; txHash?: string; error?: string }> => {\n  if (!isMetaMaskInstalled()) {\n    return { success: false, error: 'MetaMask is not installed' };\n  }\n\n  try {\n    // Dynamically import ethers to avoid issues with SSR\n    const { ethers } = await import('ethers');\n    \n    // Create Web3Provider\n    const provider = new ethers.providers.Web3Provider(window.ethereum);\n    \n    // Get the signer (current user's account)\n    const signer = provider.getSigner();\n    \n    // Create a contract instance\n    const contract = new ethers.Contract(contractAddress, abi, signer);\n    \n    // Call mint function - adjust this based on your contract's actual function\n    // Most NFT contracts use one of these patterns:\n    let tx;\n    \n    // Try different minting patterns based on the contract\n    try {\n      // Pattern 1: mint(to, tokenURI)\n      tx = await contract.mint(toAddress, tokenURI);\n    } catch (error) {\n      try {\n        // Pattern 2: safeMint(to, tokenURI)\n        tx = await contract.safeMint(toAddress, tokenURI);\n      } catch (innerError) {\n        try {\n          // Pattern 3: mintNFT(to, tokenURI)\n          tx = await contract.mintNFT(toAddress, tokenURI);\n        } catch (deepError) {\n          // If all patterns fail, try just calling 'mint' with only the tokenURI\n          // This is common for contracts where msg.sender is the recipient\n          tx = await contract.mint(tokenURI);\n        }\n      }\n    }\n    \n    // Wait for the transaction to be mined\n    const receipt = await tx.wait();\n    \n    return {\n      success: true,\n      txHash: receipt.transactionHash\n    };\n  } catch (error) {\n    console.error('Error minting NFT:', error);\n    \n    if (error instanceof Error) {\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n    \n    return {\n      success: false,\n      error: 'Unknown error occurred while minting NFT'\n    };\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}